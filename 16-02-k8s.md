## 安装 & 操作

### kubectl 客户端

资源类型可以使用缩写：replicationcontroller = rc 、pods = po 、service = svc

1. 查看集群各组件信息：`kubectl cluster-info`
2. 查看集群各节点信息：`kubectl get nodes` `kubectl describe node`
3. 列出Pod信息: `kubectl get pods` `kubectl get pods -o wide` `kubectl describe pod`
4. 创建、查看rc运行pod：`kubectl run rc名称 --image=镜像名称 --port=告诉kubectl监听的端口` `kubectl get rc`
5. 创建、查看服务： `kubectl expose rc rc名称 --type=LoadBalancer --name 服务名称` `kubectl get svc`
6. 增加期望的副本数： `kubectl scale rc rc名称 --replicas=副本数量`
7. 获取yaml配置：`kubectl get po pod名称 -o yaml`
8. 通过yaml创建pod：`kubectl create -f pod.yaml`
9. 查看yaml配置帮助： `kubectl explain pods` `kubectl explain pod.spec`
10. 获取pod日志：`kubectl logs pod名称`
11. 通过本地网络端口转发pod端口：`kubectl port-forward pod名称 本地端口:pod端口`

## 基本概念

* Pod：若干相关容器的组合，Pod包含的容器运行在同一台宿主机上，这些容器使用相同的网络命名空间、IP地址、端口、共享一块储存卷空间，互相能通过 localhost 来发现和通信，是 k8s 的最小调度单位。
* ReplicationController：用来管理Pod副本，确保任何时候都保证有指定数量的Pod副本在运行。
* Service：真实应用服务的抽象，定义Pod的逻辑集合和访问Pod集合的策略，Service将代理Pod，对外表现为一个单一访问接口。
* Label：用于区分 Pod、Service、ReplicationController 的标签，一个 label 对应一个对象，一个对象可以有多个label。
* Node：K8S 的基本操作单一，用来分配给Pod进行绑定，Pod最终运行在Node上。

## 架构

使用主从分布式架构，一个集群由多个节点组成，分为主节点和工作节点：

![417.png](./assets/417.png)

主节点：

* API服务器：提供给外部用户访问，通过它和其他组件通信。
* Scheduler：负责集群的资源调度，为新建的Pod分配机器。
* ControllerManager：执行集群级别的功能，例如复制组件、持续跟踪工作节点、处理失败节点等。
* etcd：可靠的分布式数据储存，持久化集群配置。

工作节点：

* 容器运行时：Docker、rtk或其他容器类型。
* kubelet：与API服务器通信，管理它所在节点的容器。
* KubernetesSeviceProxy：负责组件间的负载均衡网络流量。

创建一个应用的各组件的作用：

![418.png](./assets/418.png)

## 组件

### Pod

K8S创建和部署的最小单位，封装一个或多个容器(container)、存储资源(volume)、一个独立的网络IP以及管理控制容器运行方式的策略选项。

通常情况下并不会直接创建它，而是通过 ReplicationController 或 Deployment 等创建并管理，因为直接创建的Pod由K8S直接监控生命周期，如果Pod失败将会重启，如果Pod所在节点宕机，Pod将会丢失，但是由RC管理的，会更换新节点。

特性：

1. 同一个pod中容器之间部分隔离，他们共享相同的 network 和 命名空间，可通过localhost进行互相访问，容器之间文件系统相互隔离，但可以使用 Volume 共享文件目录。
2. K8S集群中所有pod都在同一个共享网络地址空间，pod之间可以通过IP地址之间互相访问，他们的网络是通过额外的软件基于真实链路实现的。

为何多个容器比单个容器包含多个进程要好？

1. 出现故障时开发人员能方便地对该故障容器进行问题排查，而不必对整个系统的各个部分进行排查。
2. 单应用水平伸缩变得更容易。
3. 方面应用于其他项目，提高复用性。
4. 升级程序时能够将影响范围控制再更小的粒度，增加应用程序生命周期管理的灵活性，避免在升级某个服务时中断相同容器中的其他进程。

何时拆分多个Pod？

1. 多层应用分散到多个pod，拆分到两个工作节点，提高架构利用率。
2. 基于不同组件的不同扩缩容需求。

何时在pod中使用多个容器？例如应用由一个主进程和多个辅助进程组成

1. 总是一起运行，不能在不同主机运行。
2. 必须一起进行扩缩容。
3. 代表一个整体而不是独立的组件。

#### YAML

yaml 文件主要由以下几部分构成：

* apiVersion: 必选，版本号，例如v1
* kind: 必选，资源类型，例如Pod
* metadata: 包括名称、命名空间、标签和关于该容器的其他信息。
* spec：最主要的部分，包含 pod 的实际内容， 例如 pod 的容器、卷和其他数据。
* status: 运行时pod的当前信息。

```yaml
apiVersion: v1            #必选，版本号，例如v1
kind: Pod                 #必选，Pod
metadata:                 #必选，元数据
  name: string        　　#必选，Pod名称
  namespace: string       #必选，Pod所属的命名空间
  labels:                 #自定义标签
    - name: string      　#自定义标签名字
  annotations:            #自定义注释列表
    - name: string
spec:                     #必选，Pod中容器的详细定义
  containers:             #必选，Pod中容器列表
  - name: string      　　#必选，容器名称
    image: string     　　#必选，容器的镜像名称
    imagePullPolicy: [Always | Never | IfNotPresent]  #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像
    command: [string]     #容器的启动命令列表，如不指定，使用打包时使用的启动命令
    args: [string]        #容器的启动命令参数列表
    workingDir: string    #容器的工作目录
    volumeMounts:         #挂载到容器内部的存储卷配置
    - name: string        #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名
      mountPath: string   #存储卷在容器内mount的绝对路径，应少于512字符
      readOnly: boolean   #是否为只读模式
    ports:                #需要暴露的端口库号列表
    - name: string        #端口号名称
      containerPort: int  #容器需要监听的端口号,该端口是展示性的，不会对应用暴露的端口造成影响
      hostPort: int       #容器所在主机需要监听的端口号，默认与Container相同
      protocol: string    #端口协议，支持TCP和UDP，默认TCP
    env:                  #容器运行前需设置的环境变量列表
    - name: string        #环境变量名称
      value: string       #环境变量的值
    resources:            #资源限制和请求的设置
      limits:             #资源限制的设置
        cpu: string       #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数
        memory: string    #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数
      requests:           #资源请求的设置
        cpu: string       #Cpu请求，容器启动的初始可用数量
        memory: string    #内存清楚，容器启动的初始可用数量
    livenessProbe:        #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可
      exec:               #对Pod容器内检查方式设置为exec方式
        command: [string] #exec方式需要制定的命令或脚本
      httpGet:            #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port
        path: string
        port: number
        host: string
        scheme: string
        HttpHeaders:
        - name: string
          value: string
      tcpSocket:          #对Pod内个容器健康检查方式设置为tcpSocket方式
         port: number
      initialDelaySeconds: 0   #容器启动完成后首次探测的时间，单位为秒
      timeoutSeconds: 0        #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒
      periodSeconds: 0         #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次
      successThreshold: 0
      failureThreshold: 0
      securityContext:
         privileged: false
    restartPolicy: [Always | Never | OnFailure] #Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod
    nodeSelector: object        #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定
    imagePullSecrets:           #Pull镜像时使用的secret名称，以key：secretkey格式指定
      - name: string
    hostNetwork: false      　　#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络
    volumes:                    #在该pod上定义共享存储卷列表
      - name: string            #共享存储卷名称 （volumes类型有很多种）
        emptyDir: {}            #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值
        hostPath:               #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录
          path: string          #Pod所在宿主机的目录，将被用于同期中mount的目录
        secret:                 #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部
          scretname: string  
          items:   
          - key: string
            path: string
        configMap:              #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部
          name: string
          items:
          - key: string
            path: string
```

#### 标签

可通过标签选择器选择以下资源：

* 包含（或不包含）使用特定键的标签
* 包含具有特定键和值的标签
* 包含具有特定键的标签， 但其值与我们指定的不同

操作：

* 添加标签：`kubectl label po pod名称 标签名称=标签值`
* 修改标签：`kubectl label po pod名称 标签名称=标签值 --overwrite`
* 查看pod并显示标签信息：`kubectl get po --show-labels` `kubectl get po -L 标签1,标签2`
* 标签选择器：`kubectl get po -l 标签名称=标签值` `kubectl get po -l 标签名称` `kubectl get po -l '!标签名称'`
* 使用标签标记node：`kubectl label node 节点名称 gpu=true` 将pod调度到特定节点:
  ![419.png](./assets/419.png)

#### 命名空间

可以将集群中的资源划分为相互隔离的组，同一名字空间内的资源名称要唯一，但跨名字空间时没有这个要求，默认情况所有资源属于default的组。

多命名空间适用于多团队、多用户、不同生命周期的场景。

#### 探针

用于检查pod是否存活，如果pod失败，则会重启pod，yaml配置中使用 livenessProbe 关键字，详情查看 pod yaml配置。

创建探针的要点：

1. 保持探针轻量，不应该消耗太多的计算资源。
2. 无须在探针中实现重试。

类型：

* HTTP GET探针：如果响应2xx或3xx 则认为探测成功。
* TCP套接字探针：如果连接成功建立，则探测成功。
* Exec探针：检查命令的退出状态码，如果状态码是 0, 则探测成功。

### 控制器

#### ReplicationController (不在使用，用RS替代)

负责管理Pod副本，确保任何时候都保证有指定数量的Pod副本在运行。

由三部分组成：

* 标签选择器：用于确定 RC 作用域中有哪些pod。
* 副本个数：指定运行pod的数量。
* pod模板：用于创建新的pod副本。

##### YAML

```yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: my-nginx
spec:
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
```

#### ReplicaSet

新一代的RC，拥有更强的标签选择器能力，可以匹配缺少某个标签的pod或特定标签名的pod，RC只能匹配包含某个标签的pod。

Job、Deployment、ReplicaSet、DaemonSet支持基于等式的选择方式和基于集合的选择方式：

```yaml
selector:
  matchLabels:
    component: redis
  matchExpressions:
    - {key: tier, operator: In, values: [cache]}
    - {key: environment, operator: NotIn, values: [dev]}
```

operator 有四个操作符：

* In : Label的值必须与其中一个指定的values 匹配。
* NotIn : Label的值与任何指定的values 不匹配。
* Exists : pod 必须包含一个指定名称的标签，不关注值。使用此运算符时，不应指定 values字段。
* DoesNotExist : pod不得包含有指定名称的标签。values属性不得指定 。

##### YAML

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      tier: frontend
  template:
    metadata:
      labels:
        tier: frontend
    spec:
      containers:
      - name: nginx
        image: registry.cn-beijing.aliyuncs.com/google_registry/nginx:1.17
        imagePullPolicy: IfNotPresent
        ports:
        - name: httpd
          containerPort: 80
```

#### DaemonSet

确保所有节点上都运行一个Pod的副本，当节点加入获取移除集群时，新增或删除一个Pod。

使用场景：
* 在每个节点上运行集群守护进程
* 在每个节点上运行日志收集守护进程
* 在每个节点上运行监控守护进程

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd-elasticsearch
  namespace: kube-system
spec:
  selector:
    matchLabels:
      name: fluentd-elasticsearch    # 负责选择 fluentd-elasticsearch 标签的节点
  template:
    metadata:
      labels:
        name: fluentd-elasticsearch
    spec:
      containers:
      - name: fluentd-elasticsearch
        image: k8s.gcr.io/fluentd-elasticsearch:1.20
        volumeMounts:
        - name: varlog
          mountPath: /var/log
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
```

### Service

负责提供一个固定的Ip和端口对外暴露Pod，解决不断变化的Pod IP地址的问题。
由于Pod是不断变化的，它可能被删除、替换、重新分配等，所有Pod的Ip地址是不断变化的，服务确保其中一个Pod接收连接，而不关心Pod运行在哪里。
