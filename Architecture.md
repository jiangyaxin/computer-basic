# 储存高性能

## 关系型数据库

分为两类：

* 读写分离：将访问压力分散到集群中的多个节点，没有分散储存压力。
* 分库分表：既可以分散访问压力，也可以分散储存压力。

### 读写分离

1. 搭建主从集群，主机负责读写操作，从机负责读操作。
2. 主机通过数据同步到从机。
3. 业务服务器将写操作发给主机，读操作发给从机。

问题：存在主从复制延迟，当主机写入后，从机没来得即复制，这时查询从机可能出现问题。

解决方法：
1. 写操作完成后读操作发给指定主机：对业务侵入较大。
2. 读从机失败后再读一次主机：二次读取和业务无绑定，值需要对数据库访问封装，但会增加主机的访问量。
3. 关键业务读写指向主机，非关键业务采用读写分离，可以接受短暂延迟。

### 分库分表

存储压力的体现：
1. 数据量太大，读写性能下降。
2. 数据文件变大，数据库备份、恢复时间长。
3. 数据文件越大，极端情况下丢失数据风险越高。

分散储存分为两类：分库、分表。

1. 业务分库：按照业务模块将数据分散到不同的数据库服务器。

带来问题：
* 无法 join 操作
* 事务问题
* 硬件成本问题

初创业务时不建议拆分：
  1. 业务不确定性,没有真正的储存和访问压力，分库不能带来价值。
  2. 业务分库后，join 和 事务无法简单实现。
  3. 分库后，不同数据写入需要不同逻辑，增加工作量，初创期间最重要的是快速实现、快速验证、业务分库会拖慢业务节奏。

2. 业务分表：分为垂直拆分和水平拆分。

垂直分表将不常用且占大量空间的列拆分出去，带来问题是 需要多次查询才能获取到数据。

水平拆分适合表行数较大的表，一般达到千万级别，就要警觉。

带来问题：
  1. 路由：某条数据属于哪个子表
    * 范围路由：根据有序的数据列作为路由条件，复杂性体现在分段大小的选取上，太小增加维护复杂度，太大仍会导致性能问题，一般会在 1000万 到 2000 万直接，优点是新增表时不用动原有数据。
    * Hash路由：复杂性体现在初始表数量的选取，太多维护复杂，太少导致单表性能问题，而且增加表数量复杂，所有数据需要重分布，优点是表分布均匀。
    * 配置路由：添加路由表记录路由信息，缺点是多查询一次，会影响整体性能，如果路由表太大也会影响性能，优点是扩充表迁移数据后只需要修改路由表即可。
  2. 需要多次join操作。
  3. 没法简单 count() 操作。
    * count相加：性能低，但实现简单。
    * 记录数表：新增记录数表，每次插入或删除子表数据后更新记录数表，缺点是容易造成数据不一致，增加数据库写压力，优点是查询简单。
  4. order by 操作无法完成：只能通过业务代码或者中间件分布查询汇总。

### 解决方案
1. 程序代码封装：实现简单，但无法通用，各个语言需要实现一次，例如 sharding-jdbc 。
2. 中间件封装：支持多种编程语言，复杂程度高，例如 mysql-proxy 。

## NoSQL

关系型数据库缺点：

1. 储存行记录，无法储存数据结构。
2. 表结构强约束，操作不存在的列报错，扩展不方便。
3. 大数据场景下 IO 较高。
4. 全文搜索能力弱。

NoSQL有4类：
1. K-V 存储：解决关系数据库无法储存数据结构的问题，如 Redis。
2. 文档数据库：解决关系数据库强schema约束问题，如MongoDB。
3. 列式数据库：解决大数据场景下IO问题，如 HBase。
4. 全文搜索引擎：解决关系数据全文搜索性能问题，如 Elasticsearch。

### K-V

优点： 支持多种数据结构存储。

缺点是不支持完整的ACID，只能保证 隔离性 和 一致性，无法保证原子性和持久性。

* 原子性：不支持原子性，不支持回滚，事务中间一条命令失败，既不会回滚，也不会终止后面的命令。
* 一致性：事务前后，数据库完整性没有被破坏。
* 隔离性：单进程单线程。
* 持久性：RDB会丢失上次持久化之后的数据，AOF先执行命令再追加日志，即使每次都刷盘，也可能丢失一条。

### 文档数据库

优点：
1. 新增字段简单，不需要DDL，直接读写即可。
2. 缺少字段，历史数据也不会出错。
3. 容易储存复制数据。

### 列式数据库

优点：
1. 同时读取多个列时效率高。
2. 能一次完成多个列的写操作。

### 全文搜索引擎

使用倒排索引优化全文搜索。

### 应用

#### 缓存

场景：
1. 需要经过负载运算后得到数据。
2. 读多写少场景。

问题：

1. 缓存穿透

* 储存数据不存在，访问集中在数据库，可以 缓存空值和布隆过滤器解决。
  1. 接口增加业务层级的Filter，进行合法校验，这可以有效拦截大部分不合法的请求。
  2. 作为第一点的补充，最常见的是使用布隆过滤器，针对一个或者多个维度，把可能存在的数据值hash到bitmap中，bitmap证明该数据不存在则该数据一定不存在，但是bitmap证明该数据存在也只能是可能存在，因为不同的数值hash到的bit位很有可能是一样的，hash冲突会导致误判，多个hash方法也只能是降低冲突的概率，无法做到避免。
  3. 另外一个常见的方法，则是针对数据库与缓存都没有的数据，对空的结果进行缓存，但是过期时间设置得较短，一般五分钟内。而这种数据，如果数据库有写入，或者更新，必须同时刷新缓存，否则会导致不一致的问题存在。

2. 缓存击穿

* 如果刚好业务访问缓存时失效，但缓存数据生产耗费大量时间和资源，访问集中在数据库。
  1. 如果是热点数据，那么可以考虑设置永远不过期。
  2. 如果数据一定会过期，那么就需要在数据为空的时候，设置一个互斥的锁，只让一个请求通过，只有一个请求去数据库拉取数据，取完数据，不管如何都需要释放锁，异常的时候也需要释放锁，要不其他线程会一直拿不到锁。

3. 缓存雪崩

* 缓存中大量数据同一时间失效。

  1. 如果是热点数据，那么可以考虑设置永远不过期。
  2. 缓存的过期时间除非比较严格，要不考虑设置一个波动随机值，比如理论十分钟，那这类key的缓存时间都加上一个1~3分钟，过期时间在7~13分钟内波动，有效防止都在同一个时间点上大量过期。
  3. 方法1避免了有效过期的情况，但是要是所有的热点数据在一台redis服务器上，也是极其危险的，如果网络有问题，或者redis服务器挂了，那么所有的热点数据也会雪崩（查询不到），因此将热点数据打散分不到不同的机房中，也可以有效减少这种情况。
  4. 也可以考虑双缓存的方式，数据库数据同步到缓存A和B，A设置过期时间，B不设置过期时间，如果A为空的时候去读B，同时异步去更新缓存，但是更新的时候需要同时更新两个缓存。

# 计算高性能
