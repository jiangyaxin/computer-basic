
操作系统是管理计算机硬件的程序，还为应用程序提供基础，并且充当用户和计算机硬件的中介。操作系统可以看作资源分配器，负责分配CPU时间、内存空间、文件储存空间、IO设备等；同时也是控制程序，负责管理用户程序的执行。

# 计算机运行

## 计算机启动

1. BOIS

   * 当电源打开或重启时，会运行一个初始程序，即 BIOS，它位于计算机固件上，如只读内存(ROM，Read-Only Memory)。
   * BIOS 首先检查硬件能否满足运行的基本条件，叫硬件自检 即 POST，Power-On Self-Test。
   * 如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。
   * POST完成后，BIOS需要将控制权转交给下一阶段的启动程序，这时需要知道下一阶段启动程序具体存放的设备，BIOS根据外部储存设备的排序(Boot Sequence)，将控制权优先转交给排在前面的设备。

2. 主引导记录

   * BIOS 将控制权交给储存设备后，计算机读取该设备的第一个扇区，即 512 字节，如果最后两个字节是 0x55 和 0xAA ，表明设备可以启动，如果不是，控制权转交给启动顺序的下一个设备。
   * 前面512字节叫做 主引导记录，即MBR，Master boot record，由三部分组成：调用操作系统的机器码、分区表、签名（0x55和0xAA），它的作用是告诉计算机到硬盘的哪一个位置去找操作系统，将控制权转交给哪个区。
   * 分区表长度只有64字节，分为4项，每项16字节，所以一个硬盘最多只能分四个主分区。
   * 主分区的第一个字节标识该分区是否是激活分区（0x80），控制权要转交给激活分区，四个主分区里面只能有一个是激活的。
   * 最后四个字节决定主分区长度，所以一个主分区的扇区总数最多不超过2的32次方，也就是一个分区最大不超过2TB，如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。

3. 硬盘启动：控制权就要转交给硬盘的某个分区了，分成三种情况：

   卷引导记录：

   * 四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做卷引导记录（VBR，Volume boot record），它作用就是告诉计算机操作系统在这个分区里的位置，随后计算机就会加载操作系统。

   扩展分区和逻辑分区：

   * 随着硬盘变大，4个分区不够用，按照规定，有且有且仅有一个区可以被定义成扩展分区，即这个区里面又分成多个区，这种分区里的分区叫做逻辑分区。
   * 计算机先读取扩展分区的第一个扇区，叫做扩展引导记录（EBR，Extended boot record），它包含64字节的分区表，里面有两个分区项，一个是自己，一个是下一个逻辑分区的位置。
   * 若没有找到激活分区，计算机接着读取第二个逻辑分区的第一个扇区，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。
   * 但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。

   启动管理器：

   * 计算机读取"主引导记录"前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的"启动管理器"（boot loader），由用户选择启动哪一个操作系统。Linux环境中，目前最流行的启动管理器是Grub。

4. 操作系统

   * 控制权转交给操作系统后，操作系统的内核首先被载入内存。
   * 以Linux系统为例，先载入/boot目录下面的kernel。
   * 内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。
   * 然后，init进程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。
   * init进程加载完成，系统就完成启动，开始等待事件的发生。

## 事件

  事件发生通常通过硬件或软件的中断来产生，硬件可以随时通过系统总线发送信号到CPU，以触发中断，软件也可通过执行特别操作即系统调用，以触发中断。
  当CPU被中断时，它会停止正在做的事， 并立即转到中断服务程序的开始地址执行，等中断服务程序执行完成后，CPU重新执行被中断的计算。

## 存储

1. 内存

   * CPU只能从内存中加载指令，因此执行程序必须位于内存，内存也称随机访问内存（RAM，Random Access Memory），除此之外还有 ROM 、寄存器、高速缓存等。
   * 所有形式的内存都提供字节数组，每个字节都有地址，操作特定内存地址通过 load 和 store 指令，load 指令将内存字节保存到CPU寄存器，store指令将寄存器保存到内存，除此之外，CPU还会自动加载内存指令以便执行。

2. 硬盘

   * 理想情况下，程序和数据都应永久驻留在内存中，但由于内存太少，不能永久保存所需要的程序和数据，同时内存是易失性设备，掉电会失掉所有内容，所以使用硬盘来永久储存大量数据。
   * 速度：寄存器 > 高速缓存 > 内存 > 固态硬盘 > 硬盘。

## IO

* 每个计算机系统都包含CPU和多个设备控制器，他们通过共同总线连一起，每个设备控制器管理某一特定类型的设备。
* 每个设备控制器维护一定量的本地缓冲存储和一组特定用途的寄存器，设备控制器负责在所控制的外围设备与本地缓冲存储之间进行数据传递。
* 操作系统为每个设备控制器提供一个驱动程序，驱动程序为操作系统其它部分提供统一的设备访问接口。

流程：

  * 开始IO时，驱动程序加载设备控制器的寄存器，通过寄存器中内存，决定采取什么操作，如 从键盘中读取一个字符。
  * 控制器开始从设备向本地缓冲区传输数据，一旦数据传输完成，设备控制器会通过中断通知驱动程序。
  * 驱动程序返回控制到操作系统，对于读操作，数据或数据指针也会返回，而对于其他操作，驱动返回状态信息。

这种IO中断驱动适合移动少量数据，但像磁盘IO大量数据移动则采用DMA，Direct Memory Access 技术，驱动只需要为这种IO设备设置好缓冲、指针和计数器之后，设备控制器可在本地缓冲和内存之间整块数据传输，无需CPU干预，每块只产生一个中断，来告知驱动已完成，而不是像低速设备一样每个字节产生一个中断，当设备控制器执行这些操作时，CPU可以进行其他工作。

## 多道程序设计

操作系统在内存中同时保存多个任务，通过安排作业使得CPU总有一个作业执行，提高CPU利用率。

由于主存太小不能容纳所有作业，这些作业首先保存在磁盘的作业池，该作业池包含磁盘上的、等待分配内存的所有进程，内存的作业集为作业池的作业集的子集。

操作系统会从内存作业集中选择一个作业执行，该作业可能等待某个任务，比如IO，CPU会简单切到另一个作业，以便执行。

作业的取决CPU调度，有多少作业可以加载到内存取决于作业调度，内存同时保存多个程序需要一定形式的内存管理。

## 一条指令的执行
